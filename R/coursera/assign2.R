cube <- function(x, n)
{
        x ^ 3
}

test <- function()
{
        x <- 1:10
        if (x > 5)
        {
                x <- 0
        }
}
####警告信息，紧使用了第一个元素

f <- function(x)
{
        g <- function(y)
        {
                y + z
        }
        z <- 4
        x + g(x)
}

h <- function(x, y = NULL, d = 3L)
{
        z <- cbind(x, d)
        if (!is.null(y))
        {
                z <- z + y
        }
        else
        {
                z <- z + f
        }
        g <- x + y/z
        if (d == 3L)
        {
                return(g)
        }
        g <- g + 10
        g
}
#########环境：由对象或符号和值组成的列表（符号值对的集合）
#########全局环境等于工作区，搜索的第一个包
#########为函数中的变量（非参数）赋值：词法作用域（静态作用域）搜索赋值
#        自由变量：没有在函数中定义，也非形参，赋值方法：在定义
#                  函数的环境搜索，然后父环境，直到顶层环境
#                 （包的命名空间：包中定义的函数），然后列表下一
#                  个元素，最后空环境（列表完了）（没有则报错）
#                  
#                  
#########父环境：环境的上一层环境
#########空环境：没有父环境的环境
#########闭包：函数闭包
#########词法作用域<->动态作用域（考虑调用环境）
#########调用环境就是父框架
#########所有编程语言最终会变成Lisp
#########词法作用域后果：所有对象都必须保存在内存里
#             每个函数都有一个指针指向它的定义环境（任何环境）
#             （函数定义函数）
#             返回值是函数的时候，必须有指针指向那个环境
#########S-plus 只能在工作区寻找自由变量值：对象可以存储在硬盘


