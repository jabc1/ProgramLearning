/**
	Cadence 面试经历
	2016/12/9星期五去公司面试的

	开场，HR给一套试卷5个题目，限时一个小时，题目难度中等吧，40分组搞定了。
	1.程序输出结果，分析原因。主要是返回局部字符数组的指针，理论上都是有问题的。但是在三七互娱面试的时候，那个非常nice的面试官和我交流过，
	这种题目不好，实际和编译器的实现有关系，因为关系到字符串常量的存储位置。如果在栈区存放，自然清栈，指针地址指向位置找不到了；但是如果
	在静态区存放，不存在清栈问题，地址是可以找得到的，可以打印。
	cadence的面试题目，一个是char temp[] = "string"; 一个是char temp[] = {'s', 't', 'r', 'i', 'n', 'g'}; 感觉这两个没有区别，当然字符串的
	形式，有结尾符'\0'，字符数组是没有的

	2.程序填空，两个递归问题。
		M叉树，定义的字符串如下：a(b(c,d),e, f(h)) 题目实际，最多三叉树
		typedef struct Node{ int data; Node* link[3];}Node;
		1.根据字符串生成一颗树。
		2.一棵树打印其构造的字符串。

	3.反转链表
	Node* reverse(Node * head)

	4.输出链表的倒数第k个字符
	Node* kthNode(Node *head, int k)

	5.C++继承问题，构造函数和析构函数执行顺序，虚函数动态绑定，非虚函数静态绑定.
	class A{ ... }
	class B public A{ ... }
	class C public B{ ... }

	面试官直接拿过去试卷，完全不看，直接来让自我介绍，看着简历，然后直接问问题，中间又来了一个面试官，一个小时以后，又来了2个。
	问题很多：
		1.熟悉map吗？
		2.线段merge，程序改了n次，要求非常细，要求边界条件修改了n次，然后不能修改本身的vector，返回一个vector。直接最后复制一次，释放局部的vector，不行，效率低下。。。。搞了1个多小时。
		
		3.排序熟悉吗？
		
		4.一个函数中，需要分配资源，如何检测资源在函数推出的时候，有没有释放？开始以为是检测，就按照检测的方式做，每次函数返回的assert，并对指针重新赋值，null。
		有很多返回，函数后面修改了，添加了资源分配怎么办？然后我就直接说，那就资源分配即可视化，使用类对象管理资源。依据构造函数和析构函数管理资源。
		写代码？然后写了下，然后问智能指针知道吗？一开始没有明白问什么，智能指针也忘记了，就说了，智能指针一般使用引用计数，实现内存管理的。
		面试官说，不是考虑智能指针的实现原理，而是说智能指针的自动内存管理的实现原理，我就说，就是这个原理啊，使用类管理，依据析构函数的自动执行。
		5.两个矩形，如何判断是否相交，我开始是正向考虑，情况太多，比较很复杂，面试官提示，反向比较。
		6.百万个矩形，如何检测是否有相交的，提高效率(否定了暴力，但是我实际分析，这个题，好像只能暴力，我开始说排序，应该不错，
		然后突然想到了k-d树，尝试了一下，思维的复杂度太高了，逻辑搞不清楚，然后我放弃了，面试管提示先一个维度排序，然后二分查找，
		感觉不行)
		
		7.二分查找知道吗，写一个代码。思考之后，写了那个最牛的二分查找，返回最后一个不超过key的元素的下标，比较2次而不是比较三次的方式。
		
		递归了解吗？递归需要注意什么？我就依据二分查找的代码解释了递归：退出条件，驱动方法
		
		8.一个文件，如何打印倒数k行？我说和笔试的链表那个题一样。
		9.多态知道吗？我说虚表和虚指针，面试官说没有了吗，我说那就是类继承，析构函数多用虚函数，现在才发现没有抓住重点，
		没有说编译期多态。
		10.面试官说知道template吗，开始没有听清楚，然后说模板，问我知不知道。然后我说知道，具体只什么方面呢，刚刚使用的vector就是
		一个模板。
		11.写一个string吧。然后我就写了四个经典函数
		12.其他面试官都没有问题后，问我有什么问题，才知道刚刚的主问题就是他们实际要解决的问题，也是醉了。
		
	2016/12/12 电话面试
	1.vector的实现机制，主要就是内存扩展，然后考虑hint的思路
	2.map的实现
	3.MST最小生成树的算法
	4.递归知道吗，递归的坏处
	5.图的搜索算法实现
	6.算法优化，非线性的约束条件，梯度下降，最小二乘法
	7.公司业务，EDA的了解，是否感兴趣
	8.愿意学习EDA中的微电子知识吗
	9.愿意维护以前的code吗
	10.评价自己，团队合作能力
	11.是否习惯英语开会，有美国团队合作
	
	题目太多，记忆有些混乱，顺序可能有些出入，但是题目没有记错，可能有漏
	
	现场面试：大约4个小时：笔试40分钟+技术面试2个半小时+HR面试四十多分钟
*/
#include <iostream>
#include <vector>

using namespace std;

struct Node{
	int x1;
	int x2;
};

int cmp(Node x, Node y){
	return x.x1 - y.x2;
}

// merge线段，方法一
vector<Node> solution(vector<Node> list){
	// sort

	vector<Node> newList;
	int i = 0;
	Node newNode;
	for (int j = i + 1; j < list.size(); j++){
		newNode = Node(list[i]);
		if (newNode.x2 < list[j].x1){
			newList.push_back(newNode);
			i = j;
		}
		else{
			newNode.x2 = list[j].x2;
		}

		if ((j == list.size() - 1) && i == j){
			newNode = Node(list[i]);
		}
	}
	newList.push_back(newNode);

	return newList;
}

// 方法二
vector<Node> solution(vector<Node> list){
	// sort

	vector<Node> newList;
	int i = 0;
	for (int j = i + 1; j < list.size(); j++){
		Node newNode = list[i];
		if (newNode.x2 < list[j].x1){
			newList.push_back(newNode);
			i = j;
		}
		else{
			newNode.x2 = list[j].x2;
		}

		if (j == list.size() - 1){
			if (i == j){
				newList.push_back(list[i]);
			}
			else{
				newList.push_back(newNode);
			}
		}
	}

	return newList;
}