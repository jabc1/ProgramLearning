##C++面试总结

转载自[C++常见面试题30道](http://blog.csdn.net/wdzxl198/article/details/9102759/)

1.new	delete	malloc	free的联系和区别

	相同点：他们都可用于动态申请内存和释放内存。
	
	不同点：
		1.malloc和free属于C/C++语言的标准库函数，new/delete是C++运算符。对于非内部数据对象(类对象)，
		malloc/free无法满足动态对象的要求。对象的创建，需要自动调用构造函数，对象超出作用域时，自动销毁，
		需要调用析构函数。库函数不是运算符，不在编译器控制权限内，所以malloc/free无法承担调用构造和析构
		函数的任务。
		2.malloc函数原型：void* malloc(size_t size); malloc返回值是void，因此必须进行强制内型转换。malloc函数
		不关注申请的内存用于什么类型，只关注申请内存的大小。
		int* p = (int*)malloc(sizeof(int) * length);
		int* p = new int[length];
		new使用更加简单，new内置了sizeof、类型转换、类型安全检查等功能。malloc不安全
		
	C++的new、delete完全包含有malloc和free的功能，但是没有去掉这两个库函数，只是因为兼容C语言程序！new的功能比malloc更加强大。
	
	new/delete配对使用，malloc/free配对使用。new对象，不能使用free释放。malloc申请内存，可以delete释放。
	
	new/delete配对使用，new[]/delete[]配对使用。
	
	delete删除一个指针，delete[]删除一个数组。delete只是调用一次析构函数，delete[]为每一个对象调用析构函数。
	对于内部内型，delete与delete[]区别不大，可以换用，但是对于类对象，不能互用。
	
2.C++有哪些性质

	类 	封装(类、成员)	继承(基类、派生类)	this指针	多态(虚函数)
	
3.多态
	
	编译时多态：函数方法的重载
	运行时多态：派生和虚函数
	
	抽象类：纯虚函数，有纯虚函数的类，属于抽象类，抽象类不能创建对象，只能用于派生出其他类。
	
	用基类的指针指向派生类对象，对于虚函数的调用，是根据实际指针指向的对象的类型，调用其函数方法，和指针类型无关。
	
	多态：多种状态，一个方法，具有多种状态，即被重写了多次(重写!=重载)
	
4. X&(X-1) 此操作，即去掉X二进制表示中的一个数字'1'。

5.引用？

	引用就别名，申明引用，必须初始化。引用的使用和普通变量完全一样。申明一个引用，不是定义，创建一个变量，只是对某一变量，
	取一个别名("绰号")。
	引用本身不占存储单元，不能给数组创建引用！
	
	函数参数，传递引用和传递指针一样，被调函数对形参变量的操作就是对主调函数中，目标的直接操作，不是操作其副本。
	传递参数对象较大的时候，引用传参，不需要产生实参副本，节省空间，效率更高。
	
	指针传参时，可以达到引用传参的高效，但是被掉函数中，同样需要给形参分配存储单元，对变量的操作，需要 (*value)操作，
	参数的传入时，必须使用变量的地址，所以引用更加简单，明了。
	
	常引用 const: 复制大的自定义对象时，需要高效率，还需保持数据安全性，应该使用常引用。
**当函数不修改参数时，最好都使用const修饰，提高程序的安全性。**

	函数返回引用，好处：效率更高，内存中不产生被返回值的副本。**不能返回局部变量的引用**
	不要返回new对象的引用，虽然一般不会出现太大问题，但是如果内存没有正确释放，会引起内存泄露。new/delete最好在一个函数中，配对使用。
	
	返回类成员的引用时，最好返回 const引用
	
	<< >> 重载输入输出的时候，返回iostream引用，希望可以拼接连续使用，为了使用更加方便。
	返回一个流对象，会重新赋值拷贝一个副本对象
	返回一个流对象指针，则不能连续使用 <<(>>)操作符。
	**因此，返回引用时唯一正确的选择**
	
	四则运算符的重载，只能返回对象，不能返回对象的引用，就是需要创建一个副本对象，用于存储。(no side effect)
	
6.结果和联合
	
	相同点：都可以有不同数据类型的成员构成。
	
	区别：结构的所有成员独占对应内存空间，联合所有成员共用一块内存空间，所以其内存大小是最大数据成员所占内存空间，
		联合只存放一个被选中的成员，因此对联合的不同成员赋值，都会重写其值，覆盖原来其他成员的值，
		结构的不同成员赋值，不影响其他成员。
	
7.不同类型与"0"的比较
	
	bool 	if (variable_b)		if (! variable_b)
	int		if (variable_i == 0)	if (variable_i != 0)
	double 	if (variable_d < 0.000001 && variable_d > -0.000001)
	pointer	if (variable_p == NULL)	if (variable_p != NULL)


		