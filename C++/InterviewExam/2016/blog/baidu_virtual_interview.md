# 百度模拟测试题
#### 第一题
1. 英文字符串数组，其中英文单词是否可以构成一条路径，前一个单词的末尾字符，
必须是后一个单词的第一个字符。如果可以则返回1，否则返回-1。

	如：["abc", "cde", "efg"], ["abc", "efg", "gfr", "cde"] ...是的
	["abc", "sde", "dec"] ...不是的
	
int getWordsArray(int num, char **arr){
	char *str = NULL;	// 字符串
	int len = 2 * num;
	char *ch = new char[len];	// 存放字符串首尾字符的数组。
	
	for (int i = 0; i < num; i++){
		str = arr[i];
		ch[i] = str[0];
		ch[i+1] = str[strlen(str)-1];
	}
	
	int hash[100] = {0};	// 存放字符出现次数的哈希表
	for (int i = 0; i < len; i++){
		hash[ch[i] - 'a']++;
	}
	
	int count = 0;
	for (int i = 0; i < 100; i++){
		if (hash[i] % 2 != 0){
			count++;
			if (count > 2){
				return -1;	// 多个奇数，肯定是不能的
			}
		}
	}
	
	return 1;
}

#### 代码解析
	
1.代码漏洞很多，太粗心了，不到一半的时间就交卷了，结果代码质量惨不忍睹。
		
	输入非法没有处理
	命名不规范，想着合理命名，就是找不到合适单词
	代码无注释，说明
	正确输入，没有考虑哈希表溢出问题，即单词不一定就是常规26个单词的大小写 100合适吗？
		
2.基本思想是对的，但是逻辑还是有漏洞
	
	单词输入两次
	首字符相同的单词 { "ab", "ac" }
	
3.逻辑完善
	
	首字符和尾字符分开处理，使用两个数组存储
	哈希表使用首字符++，尾字符--的方式实现，最后检查hash表非零个数，大于2则返回-1.
		
	
#### 第二题
2. 判断一个数字是否是完美数，完美数即一个数字刚好等于它所有因数的和，比如 28 = 1 + 2 + 4 + 7 + 14。
输入一个int参数，输出，如果是完美数，则返回1，否则0。
	
int isPerfectNumber(int num){
	int sum = num;
	
	for (int i = 1; i < num; i++){
		if (num % i == 0){
			sum -= i;
		}
	}
	
	return sum == 0;
}

#### 代码解析
	
1.代码漏洞很多，太粗心了，不到一半的时间就交卷了，结果代码质量惨不忍睹。
		
	输入非法没有处理，<= 0 情况等
	命名不规范，想着合理命名，就是找不到合适单词
	时间效率问题
		
2.基本思想是对的，需要优化时间复杂度。

	从2开始循环，1直接减去。循环上界，可以压缩，2是其因子，num/2肯定也是。